"""The WaveBlocks Project

This file contains code for automatically generate
a bunch of simulation configuration given some
sets of parameters.

@author: R. Bourquin
@copyright: Copyright (C) 2010, 2011 R. Bourquin
@license: Modified BSD License
"""

from itertools import product
import sys
import os

from WaveBlocks import GlobalDefaults


def sort_statements(alist):
    """Try to sort a list of valid python statements
    such that they all can be executed w.r.t. local variable
    references. This is some kind of topological sorting
    and uses a good ammount of black magic!!
    @param alist: The list of statements
    """

    # todo: Rewrite and improve this using reflection

    ordered_statements= []

    while len(alist) > 0:
        curlen = len(alist)

        # Try to execute each statement right now
        for item in alist:
            try:
                exec(item)
            except NameError:
                continue

            # Ah, we suceeded, append the statement to the ordered list.
            ordered_statements.append(item)
            alist.remove(item)

        if len(alist) == curlen:
            raise ValueError("Could not sort configuration statements. Maybe an unescaped string? Or possibly a dependency cycle?")

    return ordered_statements


def construct_name(filename, adict):
    """Construct a filename which contains several
    key=value pairs after a given prefix. The filename
    will end with the python extension .py
    @param filename: The beginning of the filename.
    @param names: A dict containing the key=value pairs.
    """
    # Put all key=value pairs as string into a list
    kvs = [ GlobalDefaults.kvp_ldel + str(k) + GlobalDefaults.kvp_mdel + str(v) + GlobalDefaults.kvp_rdel for k, v in adict.iteritems() ]

    # Concatenate all key=value pairs in a string
    if len(kvs) == 0:
        s = ""
    else:
        s = reduce(lambda x, y: x+y, kvs)

    # Remove duplicate kvp delimiters
    if GlobalDefaults.kvp_ldel == GlobalDefaults.kvp_rdel:
        s = s.replace(GlobalDefaults.kvp_ldel+GlobalDefaults.kvp_rdel, GlobalDefaults.kvp_ldel)

    # Remove some possibly harmful characters
    # Warning: destroys meaning of filename if some of them are used as kvp delimiters!
    s = s.replace("\"", "")
    s = s.replace("\\", "")
    s = s.replace("*", "")
    s = s.replace("?", "")
    s = s.replace("(", "")
    s = s.replace(")", "")

    # Construct full filename
    filename = filename + s + ".py"

    return filename


def write_file(filepath, settings, sort_code=False):
    """Write a configuration file containing several
    configuration statements of the form key = value.
    The I{key} has to be a valid python variable name,
    the I{value} a valid python statement.
    @param path: The filepath where to put the new files.
    @param filepath: The name and path of the output file.
    @param setting: A dict containing the key=value pairs
    """
    # Create new file
    f = open(filepath, "w")

    header = [
    "#########################################\n",
    "# This file was automatically generated #\n",
    "#########################################\n",
    "\n" ]

    f.writelines(header)

    # Write all the key=value konfiguration pairs
    code = []
    for k, v in settings.iteritems():

        statement = str(k) + " = " + str(v) + "\n"
        code.append(statement)

    if sort_code:
        code = sort_statements(code)

    f.writelines(code)

    f.close()


def generate_configurations(gp, lp, cfname="Parameters", cfpath=GlobalDefaults.path_to_autogen_configs):
    """Generate a bunch of configuration files from a set
    of global parameters which are the same in all configurations
    and a set of local parameters which differ. We compute the
    cartesian product of the sets of all local parameter.
    @param gp: A dict of global parameters.
    @param lp: A dict of local parameter lists.
    @keyword cfname: The common filename prefix. Default is I{Parameters}
    @keyword cfpath: The path where the new configuration files will be placed.
    It is interpreted relative to ".".
    """
    # Check if the destination for the new configuration files is prepared
    configpath = os.path.join(".", cfpath)

    if not os.path.lexists(configpath):
        os.mkdir(configpath)
    else:
        raise ValueError("The directory for autogenerated configurations already exists.")

    print("Global paramaters:")
    print(gp)

    print("Local parameters:")
    print(lp)

    # Sort into keys and values
    lpk = [ k for k in lp.iterkeys() ]
    lpv = [ v for v in lp.itervalues() ]

    # Compute a cartesian product of all local parameters
    VG = product(*lpv)

    # Iterate over all conbinations in the cartesian product
    i = 0
    for cv in VG:
        i += 1

        # Too bad dict comprehensions only available in python >= 2.7
        params = dict([ item for item in zip(lpk, cv) ])

        filename = construct_name(cfname, params)
        filepath = os.path.join(".", cfpath, filename)

        # Add global parameters to the dict
        params.update(gp)

        print("Current configuration:")
        print(params)

        write_file(filepath, params, sort_code=True)

    print("Wrote all "+str(i)+" configuration files.")



if __name__ == "__main__":
    """Remarks:

    - You can use any valid python statement as value
    - All statements are written to a pure python code file
    - You can write numbers, lists etc as plain text strings
    - All that is not in string form gets evaluated *right now*
    - Remember to escape python strings twice
    - You can use variable references but with great care!
    - The ordering of the statements in the output file is such that
      all statements can be executed w.r.t. local variables. This is
      some kind of topological sorting. Be warned, it's implemented
      using black magic and may fail now and then!

    That should be all ...
    """

    if len(sys.argv) >= 2:
        filepath = sys.argv[1]
    else:
        filepath = GlobalDefaults.file_metaconfiguration

    if len(sys.argv) >= 3:
        configpath = sys.argv[2]
    else:
        configpath = GlobalDefaults.path_to_autogen_configs

    print("Meta configuration read from: " + filepath)
    print("Write configurations to: " + configpath)

    # Read the configuration file
    f = open(filepath)
    content = f.read()
    f.close()

    # Execute the metaconfiguration file
    # Assuming that it defines the two dicts 'GP' and 'LP' in the toplevel namespace.
    exec(content)

    # Generate the configuration files
    generate_configurations(GP, LP, cfpath=configpath)
